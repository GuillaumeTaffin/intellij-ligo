{
  parserClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.parser.JsLigoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="JsLigo"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi"
  psiImplPackage="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.impl"

  elementTypeHolderClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoTypes"
  elementTypeClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoElementType"
  tokenTypeClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoTokenType"

  extends(".*typexpr")=typexpr
  extends(".*expr")=expr
}

root ::= (<<repeat_seperated_by top_level_statement statement_separator?>> statement_separator?)?

private top_level_statement ::= namespace_statement | type_alias_statement | var_binding_statement

var_binding_statement ::=
    (CONST_KW|LET_KW)
    composed_id
    (COLON typexpr)?
    EQ
    expr

type_alias_statement ::= TYPE_ALIAS_KW IDENTIFIER EQ typexpr

typexpr ::=
    ref_typexpr
    | tuple_typexpr
    | record_typexpr
    | func_def_typexpr

ref_typexpr ::= IDENTIFIER (type_argument_list)?
tuple_typexpr ::= <<tuple ref_typexpr>>
record_typexpr ::= OPEN_BRACE [ !CLOSE_BRACE record_field_def  (COMMA record_field_def) * ] CLOSE_BRACE
record_field_def ::= IDENTIFIER COLON typexpr
func_def_typexpr ::= func_def_param_list arrow typexpr
func_def_param_list ::= OPEN_PARENS [ !CLOSE_PARENS func_def_param  (COMMA func_def_param) * ] CLOSE_PARENS
func_def_param ::= (IDENTIFIER) COLON typexpr

namespace_statement ::= NAMESPACE_KW IDENTIFIER <<code_block root>>

type_argument_list ::= LEFT_ANGLE_BRACKET <<repeat_seperated_by IDENTIFIER COMMA>> RIGHT_ANGLE_BRACKET

meta tuple ::= <<block OPEN_BRACKET <<repeat_seperated_by <<rule>> COMMA>> CLOSE_BRACKET>>

meta record ::= <<block OPEN_BRACE <<repeat_seperated_by <<rule>> COMMA>> CLOSE_BRACE>>

private meta repeat_seperated_by ::= (<<rule>> ( <<separator>> <<rule>>)*)

expr ::=
  func_expr
  | conditional_group
  | add_group
  | boolean_group
  | mul_group
  | unary_group
  | modulo_expr
  | call_expr
  | qualification_expr
  | func_call_expr
  | primary_group
  {extraRoot=true}

private conditional_group ::= conditional_expr
private add_group ::= plus_expr | minus_expr
private boolean_group ::= xor_expr
private mul_group ::= mul_expr | div_expr
private unary_group ::= unary_min_expr | unary_not_expr
private primary_group ::= simple_ref_expr | literal_expr |  paren_expr | tuple_expr | record_expr

fake ref_expr ::= expr? DOT IDENTIFIER
simple_ref_expr ::= IDENTIFIER (type_hint ! arg_list)? {extends=ref_expr elementType=ref_expr}
qualification_expr ::= expr DOT IDENTIFIER type_hint? {extends=ref_expr elementType=ref_expr}
func_call_expr ::= IDENTIFIER arg_list type_hint? {extends=ref_expr elementType=ref_expr}
call_expr ::= ref_expr arg_list type_hint?
arg_list ::= OPEN_PARENS [ !CLOSE_PARENS expr  (COMMA expr) * ] CLOSE_PARENS {pin(".*")=1}
literal_expr ::= (NUMBER_LITERAL | STRING_LITERAL) type_hint?
unary_min_expr ::= MINUS expr
unary_not_expr ::= BANG expr
xor_expr ::= expr XOR expr
conditional_expr ::= expr (LEFT_ANGLE_BRACKET | RIGHT_ANGLE_BRACKET | LEFT_ANGLE_BRACKET EQ | RIGHT_ANGLE_BRACKET EQ | EQ EQ | BANG EQ) expr
div_expr ::= expr DIV expr
mul_expr ::= expr MUL expr
minus_expr ::= expr MINUS expr
plus_expr ::= expr PLUS expr
modulo_expr ::= expr MODULO expr
paren_expr ::= OPEN_PARENS expr CLOSE_PARENS
tuple_expr ::= <<tuple (expr | spread_expr)?>>
record_expr ::= OPEN_BRACE [ !CLOSE_BRACE record_field_expr  (COMMA record_field_expr) * ] CLOSE_BRACE
record_field_expr ::= (IDENTIFIER COLON expr) | spread_expr
spread_expr ::= SPREAD_OP expr

func_expr ::= type_argument_list? func_param_list (COLON typexpr)? arrow (expr | func_block)
func_param_list ::= OPEN_PARENS [ !CLOSE_PARENS func_param  (COMMA func_param) * ] CLOSE_PARENS
func_param ::= composed_id (COLON typexpr)?
composed_id ::= (simple_id | <<tuple simple_id>> | <<record simple_id>>)
private simple_id ::= (IDENTIFIER | WILDCARD)
func_block ::= OPEN_BRACE (func_statement statement_separator?)* CLOSE_BRACE {pin(".*")=1}
private func_statement ::= (type_alias_statement | var_binding_statement | return_statement)
arrow ::= EQ RIGHT_ANGLE_BRACKET
return_statement ::= RETURN_KW expr

private type_hint ::= AS_KW typexpr

meta code_block ::= <<block OPEN_BRACE <<rule>> CLOSE_BRACE>>

private meta block ::= <<open_token>>  <<rule>>  <<close_token>>

private left statement_separator ::= SEMICOLON