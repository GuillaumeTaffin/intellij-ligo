{
  parserClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.parser.JsLigoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="JsLigo"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi"
  psiImplPackage="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.impl"

  elementTypeHolderClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoTypes"
  elementTypeClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoElementType"
  tokenTypeClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoTokenType"

}

source_file ::= (<<repeat_seperated_by top_level semicolon?>> semicolon?)?

private top_level ::=
    top_level_binding
    | type_alias_declaration
    | comment

private comment ::= line_comment | block_comment

line_comment ::= LINE_COMMENT_START COMMENT_TEXT?

block_comment ::= BLOCK_COMMENT_START COMMENT_TEXT? BLOCK_COMMENT_END

type_alias_declaration ::= TYPE_ALIAS_KW IDENTIFIER EQ type_name

private type_name ::= IDENTIFIER (type_argument_list)?

type_argument_list ::= LT <<repeat_seperated_by IDENTIFIER COMMA>> GT

top_level_binding ::=
    (CONST_KW|LET_KW)
    IDENTIFIER
    (COLON type_name)?
    EQ
    expression

expression ::= expression_literal

private expression_literal ::= string_literal
    | number_expression

number_expression ::= MINUS? <<repeat_seperated_by number_literal operator>>

number_literal ::= <<literal (ZERO_NUMBER | NON_ZERO_NUMBER)>>

string_literal ::= <<literal STRING_PATTERN>>

operator ::= PLUS | MINUS

private left semicolon ::= SEMICOLON

private meta repeat_seperated_by ::= (<<rule>> (<<separator>> <<rule>>)*)

private meta literal ::= <<with_parens <<with_optional_type_hint <<rule>> >> >>

private meta with_optional_type_hint ::= <<rule>> (AS_KW IDENTIFIER)?

private meta with_parens ::= (OPENING_PARENS <<with_parens <<rule>>>> CLOSING_PARENS) | <<rule>>