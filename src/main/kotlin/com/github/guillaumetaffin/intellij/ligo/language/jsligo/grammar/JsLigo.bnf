{
  parserClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.parser.JsLigoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="JsLigo"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi"
  psiImplPackage="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.impl"

  elementTypeHolderClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoTypes"
  elementTypeClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoElementType"
  tokenTypeClass="com.github.guillaumetaffin.intellij.ligo.language.jsligo.psi.JsLigoTokenType"

  extends(".*expr")=expr
}

root ::= (<<repeat_seperated_by top_level_statement statement_separator?>> statement_separator?)?

private top_level_statement ::= namespace_statement | type_alias_statement | var_binding_statement

var_binding_statement ::=
    (CONST_KW|LET_KW)
    IDENTIFIER
    (COLON type_expression)?
    EQ
    expr

type_alias_statement ::= TYPE_ALIAS_KW IDENTIFIER EQ type_expression

type_expression ::= type_ref | <<tuple type_ref>>

type_ref ::= IDENTIFIER (type_argument_list)?

namespace_statement ::= NAMESPACE_KW IDENTIFIER <<code_block root>>

type_argument_list ::= LEFT_ANGLE_BRACKET <<repeat_seperated_by IDENTIFIER COMMA>> RIGHT_ANGLE_BRACKET

meta tuple ::= <<block OPEN_BRACKET <<repeat_seperated_by <<rule>> COMMA>> CLOSE_BRACKET>>

private left statement_separator ::= SEMICOLON

private meta repeat_seperated_by ::= (<<rule>> ( <<separator>> <<rule>>)*)

meta code_block ::= <<block OPEN_BRACE <<rule>> CLOSE_BRACE>>

private meta block ::= <<open_token>>  <<rule>>  <<close_token>>

expr ::= conditional_group
  | add_group
  | boolean_group
  | mul_group
  | unary_group
  | modulo_expr
  | call_expr
  | qualification_expr
  | primary_group
  {extraRoot=true}

private conditional_group ::= conditional_expr
private add_group ::= plus_expr | minus_expr
private boolean_group ::= xor_expr
private mul_group ::= mul_expr | div_expr
private unary_group ::= unary_min_expr | unary_not_expr
private primary_group ::= simple_ref_expr | literal_expr | paren_expr

fake ref_expr ::= expr? DOT IDENTIFIER
simple_ref_expr ::= IDENTIFIER (type_hint ! arg_list)? {extends=ref_expr elementType=ref_expr}
qualification_expr ::= expr DOT IDENTIFIER type_hint? {extends=ref_expr elementType=ref_expr}
call_expr ::= ref_expr arg_list type_hint?
arg_list ::= OPEN_PARENS [ !CLOSE_PARENS expr  (COMMA expr) * ] CLOSE_PARENS {pin(".*")=1}
literal_expr ::= (NUMBER_LITERAL | STRING_LITERAL) type_hint?
unary_min_expr ::= MINUS expr
unary_not_expr ::= BANG expr
xor_expr ::= expr XOR expr
conditional_expr ::= expr (LEFT_ANGLE_BRACKET | RIGHT_ANGLE_BRACKET | LEFT_ANGLE_BRACKET EQ | RIGHT_ANGLE_BRACKET EQ | EQ EQ | BANG EQ) expr
div_expr ::= expr DIV expr
mul_expr ::= expr MUL expr
minus_expr ::= expr MINUS expr
plus_expr ::= expr PLUS expr
modulo_expr ::= expr MODULO expr
paren_expr ::= OPEN_PARENS expr CLOSE_PARENS

private type_hint ::= AS_KW type_expression
